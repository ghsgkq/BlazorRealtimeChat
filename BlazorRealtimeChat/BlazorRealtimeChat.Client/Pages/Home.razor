@page "/"
@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))

@using System.Security.Claims
@using System.Text.Json
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.AspNetCore.Components.Authorization
@using BlazorRealtimeChat.Client.Layout
@using BlazorRealtimeChat.Client.Services
@using BlazorRealtimeChat.Shared.DTOs
@using Blazored.LocalStorage
@using Microsoft.JSInterop

@layout EmptyLayout
@implements IAsyncDisposable

@inject IAuthService AuthService
@inject IServiceProvider ServiceProvider
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject IServerService ServerService
@inject IChannelService ChannelService
@inject ILocalStorageService LocalStorage
@inject IMessageService messageService
@inject IFileService fileService
@inject IUserService userService

<div class="d-flex home-container">
    <!-- 1. 서버 목록 사이드바 -->
    <div class="server-list-sidebar d-flex flex-column align-items-center p-2">
        @if (servers != null)
        {
            @foreach (var server in servers)
            {
                <div class="server-icon @(selectedServer == server ? "selected" : "")" @onclick="() => SelectServer(server)">
                    @server.ServerName.Substring(0, 1)
                </div>
            }
        }
        <div class="server-separator"></div>
        <div class="server-icon" @onclick="HandleCreateServer">+</div>
    </div>

    <!-- 2. 채널 목록 사이드바 -->
    <div class="channel-sidebar bg-dark text-light flex-shrink-0" style="display: flex; flex-direction: column;">
        @if (selectedServer != null)
        {
            <div class="p-3 border-bottom border-secondary">
                <h5 class="fw-bold mb-0">@selectedServer.ServerName</h5>
            </div>
            <div class="d-flex justify-content-between align-items-center p-3">
                <span class="small text-uppercase">채널</span>
                <button class="btn btn-sm text-light" @onclick="ToggleAddChannelInput">+</button>
            </div>

            <ul class="list-unstyled p-2">
                @if (showAddChannelInput)
                {
                    <li class="p-3 mb-3 create-channel-box rounded">
                        <EditForm Model="newChannel" OnValidSubmit="HandleCreateChannel">
                            <DataAnnotationsValidator />

                            <div class="mb-3">
                                <label class="create-label text-uppercase mb-2">채널 유형</label>

                                <div class="channel-type-card @(newChannel.Type == Shared.Enums.ChannelType.Text ? "active" : "")"
                                     @onclick="() => newChannel.Type = Shared.Enums.ChannelType.Text">
                                    <div class="d-flex align-items-center w-100">
                                        <i class="bi bi-hash fs-3 me-3"></i>
                                        <div class="flex-grow-1">
                                            <div class="type-title">Text</div>
                                            <div class="type-desc">메시지, 이미지, GIF를 보냅니다.</div>
                                        </div>
                                        <div class="type-radio">
                                            <div class="radio-circle @(newChannel.Type == Shared.Enums.ChannelType.Text ? "checked" : "")"></div>
                                        </div>
                                    </div>
                                </div>

                                <div class="channel-type-card mt-2 @(newChannel.Type == Shared.Enums.ChannelType.Voice ? "active" : "")"
                                     @onclick="() => newChannel.Type = Shared.Enums.ChannelType.Voice">
                                    <div class="d-flex align-items-center w-100">
                                        <i class="bi bi-volume-up-fill fs-3 me-3"></i>
                                        <div class="flex-grow-1">
                                            <div class="type-title">Voice</div>
                                            <div class="type-desc">음성, 비디오로 함께 어울립니다.</div>
                                        </div>
                                        <div class="type-radio">
                                            <div class="radio-circle @(newChannel.Type == Shared.Enums.ChannelType.Voice ? "checked" : "")"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="mb-3">
                                <label class="create-label text-uppercase mb-1">채널 이름</label>
                                <div class="input-container">
                                    <span class="input-prefix">#</span>
                                    <InputText @bind-Value="newChannel.ChannelName"
                                               class="discord-input"
                                               placeholder="새-채널" />
                                </div>
                                <ValidationMessage For="@(() => newChannel.ChannelName)" class="text-danger small mt-1" />
                            </div>

                            <div class="d-flex justify-content-end gap-2 mt-4">
                                <button type="button" class="btn btn-sm btn-link text-white text-decoration-none" @onclick="ToggleAddChannelInput">취소</button>
                                <button type="submit" class="btn btn-sm btn-discord">채널 만들기</button>
                            </div>
                        </EditForm>
                    </li>
                }

                @if (isLoadingChannels)
                {
                    <li class="p-2 text-muted">채널 목록을 불러오는 중...</li>
                }
                else if (channels != null && channels.Any())
                {
                    @* 텍스트 채널 그룹 *@
                    <div class="channel-group-header px-3 mt-3 d-flex justify-content-between align-items-center">
                        <span class="small text-uppercase fw-bold text-secondary" style="font-size: 0.7rem;">텍스트 채널</span>
                        <button class="btn btn-sm text-secondary p-0" @onclick="ToggleAddChannelInput"><i class="bi bi-plus-lg"></i></button>
                    </div>
                    <ul class="list-unstyled p-2">
                        @foreach (var channel in channels.Where(c => c.Type == Shared.Enums.ChannelType.Text))
                        {
                            <li class="channel-item p-2 rounded @(selectedTextChannel?.ChannelId == channel.ChannelId ? "selected" : "")"
                                @onclick="() => SelectChannel(channel)">
                                <i class="bi bi-hash me-2 opacity-50"></i><span>@channel.ChannelName</span>
                            </li>
                        }
                    </ul>

                    @* 음성 채널 그룹 *@
                    <div class="channel-group-header px-3 mt-3">
                        <span class="small text-uppercase fw-bold text-secondary" style="font-size: 0.7rem;">음성 채널</span>
                    </div>
                    <ul class="list-unstyled p-2">
                        @foreach (var channel in channels.Where(c => c.Type == Shared.Enums.ChannelType.Voice))
                        {
                            <li class="channel-item p-2 rounded @(selectedVoiceChannel?.ChannelId == channel.ChannelId ? "selected" : "")"
                                @onclick="() => SelectChannel(channel)">
                                <i class="bi bi-volume-up-fill me-2 opacity-50"></i><span>@channel.ChannelName</span>
                            </li>

                            @* 해당 채널에 유저가 있을 때만 목록 표시 *@
                            @if (voiceRoomUsers.TryGetValue(channel.ChannelId.ToString(), out var users) && users.Any())
                            {
                                <div class="ms-4 mb-2">
                                    @foreach (var user in users)
                                    {
                                        <div class="d-flex align-items-center mb-1 py-1 user-voice-item">
                                            @* 프로필 이미지 또는 첫 글자 *@
                                            @if (!string.IsNullOrEmpty(user.ProfileImageUrl))
                                            {
                                                <img src="@user.ProfileImageUrl" class="rounded-circle me-2" style="width: 20px; height: 20px; object-fit: cover;" />
                                            }
                                            else
                                            {
                                                <div class="bg-secondary rounded-circle me-2 d-flex align-items-center justify-content-center text-white"
                                                     style="width: 20px; height: 20px; font-size: 0.6rem;">
                                                    @user.UserName[0]
                                                </div>
                                            }
                                            <span class="small text-secondary">@user.UserName</span>
                                        </div>
                                    }
                                </div>
                            }
                        }
                    </ul>
                }
                else
                {
                    <li class="p-2 text-muted">채널이 없습니다.</li>
                }
            </ul>
        }
        @* 음성 채널에 접속 중일 때만 나타나는 디스코드 스타일 하단바 *@
        @if (selectedVoiceChannel != null)
        {
            <div class="voice-connection-panel p-2 bg-dark border-top border-secondary">
                <div class="d-flex align-items-center">
                    <div class="flex-grow-1">
                        <div class="text-success small fw-bold"><i class="bi bi-broadcast me-1"></i> 음성 연결됨</div>
                        <div class="text-muted" style="font-size: 0.75rem;">@selectedVoiceChannel.ChannelName</div>
                    </div>
                    <div class="d-flex gap-2">
                        <button class="btn btn-sm btn-outline-light border-0"><i class="bi bi-mic-fill"></i></button>
                        <button class="btn btn-sm btn-outline-danger border-0" @onclick="LeaveVoiceChannel">
                            <i class="bi bi-telephone-x-fill"></i>
                        </button>
                    </div>
                </div>
            </div>
        }
        <label for="profileInput" class="user-profile mt-auto p-3 d-flex align-items-center" style="cursor: pointer; width: 100%;">
            @if (!string.IsNullOrEmpty(currentProfileUrl))
            {
                <img src="@currentProfileUrl" class="rounded-circle me-2" style="width: 32px; height: 32px; object-fit: cover;" />
            }
            else
            {
                <span class="bg-primary rounded-circle me-2 text-white fw-bold"
                      style="width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-size: 0.9rem;">
                    @currentUsername?.Substring(0, 1).ToUpper()
                </span>
            }
            <span class="fw-bold">@currentUsername</span>

            @* 2. InputFile은 label 바깥 혹은 안쪽 어디에 있어도 id만 일치하면 작동합니다. 
          중요: label 안에 있을 때 클릭 이벤트가 꼬이지 않도록 스타일로 숨깁니다. *@
            <InputFile OnChange="HandleProfileImageUpload" id="profileInput" style="display:none;" />
        </label>
    </div>

    <!-- 3. 메인 콘텐츠 (채팅창) -->
    <div class="main-content d-flex flex-column flex-grow-1">
        <div class="chat-messages flex-grow-1 p-3" @ref="chatMessagesBox" style="overflow-y: auto;">
            @foreach (var message in chatMessages)
            {
                <div class="d-flex mb-3">
                    @((MarkupString)message)
                </div>
            }
        </div>

        <div class="chat-input p-3 bg-dark-subtle">
            <div class="input-group">
                @* 1. InputFile은 그대로 두되, ID를 확실히 지정합니다 *@
                <InputFile OnChange="HandleFileSelected" id="fileInput" style="display:none;" />

                @* 2. button 대신 label을 사용합니다. for="fileInput"이 핵심입니다! *@
                @* 이 label을 클릭하면 브라우저가 알아서 ID가 fileInput인 요소를 클릭해줍니다. *@
                <label for="fileInput" class="btn btn-outline-secondary text-light d-flex align-items-center justify-content-center" style="cursor: pointer; width: 45px;">
                    +
                </label>

                <input type="text" id="msgInput" class="form-control bg-dark text-light border-secondary"
                       placeholder="@($"# {selectedTextChannel?.ChannelName ?? ""}에 메시지 보내기")"
                       @bind="messageInput" @onkeyup="HandleChatInput" disabled="@(!isChatConnected)" />
            </div>
        </div>
    </div>
</div>

@code {
    private List<ServerDto> servers = new List<ServerDto>();
    private List<ChannelDto> channels = new List<ChannelDto>();
    private ServerDto? selectedServer;

    // 기존 selectedChannel을 두 개로 분리합니다.
    private ChannelDto? selectedTextChannel; // 현재 채팅 중인 채널
    private ChannelDto? selectedVoiceChannel; // 현재 통화 중인 채널


    private CreateChannelDto newChannel = new CreateChannelDto();
    private bool showAddChannelInput = false;
    private bool isLoadingChannels = false;

    // --- 채팅 관련 필드 ---
    [CascadingParameter]
    private Task<AuthenticationState>? AuthenticationStateTask { get; set; }
    private HubConnection? hubConnection;
    private List<string> chatMessages = new List<string>();
    private string? messageInput;
    private string? currentUsername;
    private bool isChatConnected => hubConnection?.State == HubConnectionState.Connected;

    private Task? _signalRInitTask; // SignalR 초기화 상태를 추적하는 태스크

    private ElementReference chatMessagesBox; // 채팅 Dom 참조

    private DotNetObjectReference<Home>? _objRef; // 필드로 선언

    private string? currentProfileUrl; // 현재 사용자의 프로필 URL

    private Dictionary<string, List<VoiceUserDto>> voiceRoomUsers = new();

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateTask;
        var userInfo = await userService.GetUserByUserIdAsync();
        currentUsername = userInfo?.UserName ?? "Anonymous";
        currentProfileUrl = userInfo?.ProfileImageUrl;

        // 1. 초기화 태스크를 변수에 저장합니다. (await 하지 않고 바로 다음으로 넘어감)
        _signalRInitTask = InitializeSignalR();

        // 2. 서버 목록은 바로 불러옵니다.
        await LoadInitialServers();
    }

    private async Task InitializeSignalR()
    {
        // 1. HubConnection 빌드 (기존과 동일)
        hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri("/chathub"), options =>
            {
                options.AccessTokenProvider = async () =>
                    await LocalStorage.GetItemAsync<string>("accessToken");
            })
            .WithAutomaticReconnect()
            .Build();

        // 메시지 수신 핸들러 등록
        hubConnection.On<string, string, string>("ReceiveMessage", async (user, userProfileUrl,message) =>
        {
            var formattedMessage = FormatMessage(user,userProfileUrl, "text", "", DateTime.Now, message);
            chatMessages.Add(formattedMessage);
            await InvokeAsync(StateHasChanged);
            // 메시지 최신화 후, 메시지 스크롤을 가장 아래로 내린다.
            await ScrollToBottomChatMessagesBox();
        });

        // 파일 메시지 수신 핸들러 등록
        hubConnection.On<string, string, string, string>("ReceiveMessageWithFile", async (userName,userProfileUrl, fileUrl, messageType) =>
        {
            var fileMessageHtml = FormatMessage(userName, userProfileUrl, messageType, fileUrl, DateTime.Now, "");
            chatMessages.Add(fileMessageHtml);
            await InvokeAsync(StateHasChanged);
            // 메시지 최신화 후, 메시지 스크롤을 가장 아래로 내린다.
            await Task.Delay(100);
            await ScrollToBottomChatMessagesBox();

        });

        // 상대방이 보낸 신호(Offer/Answer/ICE)를 받았을 때 JS로 전달
        hubConnection.On<string, string>("ReceiveSignal", async (senderId, signal) =>
        {
            await JSRuntime.InvokeVoidAsync("webrtcFunctions.handleSignal", senderId, signal);
        });

        // 새로운 유저가 음성 채널에 들어왔을 때, JS에서 연결을 시작(Offer 생성)하도록 함
        hubConnection.On<string>("UserJoinedVoice", async (senderId) =>
        {
            await JSRuntime.InvokeVoidAsync("webrtcFunctions.initializeConnection", senderId);
        });

        hubConnection.On<string, List<VoiceUserDto>>("UpdateVoiceUsers", (channelId, users) =>
        {
            voiceRoomUsers[channelId] = users;
            StateHasChanged();
        });

        try
        {
            // 2. 서버와 연결 시작
            await hubConnection.StartAsync();
            Console.WriteLine("SignalR 연결 성공!");

            // [핵심] 연결이 완료되었음을 UI에 알려 input의 disabled를 해제합니다.
            await InvokeAsync(StateHasChanged);

            // [추가] 연결 전에 이미 채널이 선택되어 있었다면, 지금 서버에 Join을 요청합니다.
            if (selectedTextChannel != null)
            {
                await hubConnection.SendAsync("JoinChannel", selectedTextChannel.ChannelId.ToString());
                Console.WriteLine($"연결 후 채널 입장 완료: {selectedTextChannel.ChannelName}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SignalR 연결 실패: {ex.Message}");
        }
    }

    // 자바스크립트에서 호출할 시그널 전송 메서드
    [JSInvokable("SendSignalToHex")]
    public async Task SendSignalToHex(string targetId, string signal)
    {
        if (hubConnection != null && hubConnection.State == HubConnectionState.Connected)
        {
            // 서버의 ChatHub.SendSignal 메서드 호출
            await hubConnection.SendAsync("SendSignal", targetId, signal);
        }
    }

    private async Task LoadInitialServers()
    {
        try
        {
            servers = await ServerService.GetServersAsync();
            if (servers != null && servers.Any())
            {
                await SelectServer(servers.First());
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"서버 목록을 불러오는 데 실패했습니다: {ex.Message}");
        }
    }

    private async Task SelectServer(ServerDto server)
    {
        selectedServer = server;
        selectedTextChannel = null; // 다른 서버 선택 시, 현재 선택된 채널을 초기화합니다.
        selectedVoiceChannel = null;
        isLoadingChannels = true;
        channels = new List<ChannelDto>(); 
        chatMessages.Clear();
        StateHasChanged();

        try
        {
            // Api 호출 직전 로그
            Console.WriteLine($"호출 중: api/servers/{server.ServerId}/channels");

            channels = await ChannelService.GetChannelsAsync(server.ServerId);

            // 서버 선택 시 현재 모든 채널의 음성 접속자 정보를 가져옵니다.
            if (hubConnection?.State == HubConnectionState.Connected)
            {
                var voiceState = await hubConnection.InvokeAsync<Dictionary<string, List<VoiceUserDto>>>("GetVoiceUsersState");
                if (voiceState != null)
                {
                    voiceRoomUsers = voiceState;
                }
            }

            // 데이터 확인 로그
            Console.WriteLine($"가져온 채널 개수: {channels?.Count ?? 0}");
        }
        catch (Exception ex)
        { 
            Console.WriteLine($"{server.ServerName} 서버의 채널 목록을 불러오는 데 실패했습니다: {ex.Message}");
            channels = new List<ChannelDto>();
        }
        finally
        {
            isLoadingChannels = false;
        }

        // 서버를 선택하면 첫 번째 채널을 자동으로 선택
        if (channels != null && channels.Any())
        {
            await SelectChannel(channels.First());
        }
        else
        {
            // 채널이 없는 경우, UI를 한번 더 갱신하여 "채널을 선택하세요"가 표시되도록 합니다.
            StateHasChanged();
        }
    }
    private async Task SelectChannel(ChannelDto channel)
    {
        if (channel == null) return;

        if (channel.Type == Shared.Enums.ChannelType.Text)
        {
            // 1. 텍스트 채널 로직
            await JoinTextChannel(channel);
        }
        else if (channel.Type == Shared.Enums.ChannelType.Voice)
        {
            // 2. 음성 채널 로직
            await JoinVoiceChannel(channel);
        }


    }

    private async Task JoinTextChannel(ChannelDto channel)
    {
        // 1. hubConnection이 생성되었고 연결된 상태인지 먼저 확인합니다.
        if (hubConnection != null && hubConnection.State == HubConnectionState.Connected)
        {
            try
            {
                // 2. 기존에 선택된 채널이 있었다면 먼저 나갑니다.
                if (selectedTextChannel != null)
                {
                    await hubConnection.SendAsync("LeaveChannel", selectedTextChannel.ChannelId.ToString());
                }

                selectedTextChannel = channel;
                chatMessages.Clear();

                // 메시지 로드
                var history = await messageService.GetMessagesByChannelIdAsync(channel.ChannelId);
                foreach (var msg in history)
                {
                    var formattedMessage = FormatMessage(
                        msg.UserName,
                        msg.ProfileImageUrl,
                        msg.MessageType,
                        msg.FileUrl,
                        msg.Timestamp,
                        msg.Content);
                    chatMessages.Add(formattedMessage);
                }

                // 3. 서버의 JoinChannel 메서드를 호출합니다.
                await hubConnection.SendAsync("JoinChannel", selectedTextChannel.ChannelId.ToString());
            }
            catch (Exception ex)
            {
                // 여기서 에러가 나더라도 UI 상태는 업데이트하여 선택은 되게 합니다.
                Console.WriteLine($"채널 입장 중 SignalR 오류: {ex.Message}");
            }
        }
        else
        {
            // 연결 전이라면 화면에 표시할 데이터만 업데이트합니다.
            selectedTextChannel = channel;
            chatMessages.Clear();


        }

        StateHasChanged();
        // 메시지 최신화 후, 메시지 스크롤을 가장 아래로 내린다.
        await ScrollToBottomChatMessagesBox();
    }

    private async Task JoinVoiceChannel(ChannelDto channel)
    {


        if (selectedVoiceChannel?.ChannelId == channel.ChannelId) return;

        // 만약 이미 다른 음성 채널이 있다면, 리소스를 먼저 정리한다
        if (selectedVoiceChannel != null)
        {
            LeaveVoiceChannel();
        }

        // 1. [중요] 기존에 접속한 음성 채널이 있었다면 서버에 퇴장 알림
        if (selectedVoiceChannel != null && hubConnection != null)
        {
            await hubConnection.SendAsync("LeaveVoiceGroup", selectedVoiceChannel.ChannelId.ToString());
        }

        // 2. 마이크 권한 요청 및 스트림 시작
        var hasMic = await JSRuntime.InvokeAsync<bool>("webrtcFunctions.startLocalStream", _objRef);
        if (!hasMic) return;

        selectedVoiceChannel = channel;

        // 3. 서버에 입장 알림
        if (hubConnection != null)
        {
            await hubConnection.SendAsync("JoinVoiceGroup",
                channel.ChannelId.ToString(),
                currentUsername,
                currentProfileUrl ?? "");
        }
        StateHasChanged();
    }



    private async Task HandleCreateServer()
    {
        // SweetAlert2는 string이 아닌 JSON 객체를 반환하므로, JsonElement로 받습니다.
        var swalResult = await JSRuntime.InvokeAsync<JsonElement>("Swal.fire", new
        {
            title = "새 서버 만들기",
            text = "서버 이름을 입력하세요:",
            input = "text",
            showCancelButton = true,
            confirmButtonText = "만들기",
            cancelButtonText = "취소"
        });

        // 사용자가 '취소'를 누르지 않았고, 'value' 속성이 존재하는지 확인합니다.
        if (swalResult.TryGetProperty("value", out var valueElement) && valueElement.ValueKind == JsonValueKind.String)
        {
            string serverName = valueElement.GetString();

            if (string.IsNullOrWhiteSpace(serverName)) return;

            try
            {
                var newServerDto = new CreateServerDto { ServerName = serverName };
                var createdServer = await ServerService.CreateServerAsync(newServerDto);

                if (createdServer != null)
                {
                    servers.Add(createdServer);
                    await SelectServer(createdServer);
                    StateHasChanged();
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("Swal.fire", "오류", "서버를 만들지 못했습니다. API가 null을 반환했습니다.", "error");
                }
            }
            catch (Exception ex)
            {
                await JSRuntime.InvokeVoidAsync("Swal.fire", "치명적 오류", $"서버 생성 중 예외가 발생했습니다: {ex.Message}", "error");
            }
        }
    }

    private void ToggleAddChannelInput()
    {
        showAddChannelInput = !showAddChannelInput;
    }

    private async Task HandleCreateChannel()
    {
        if (selectedServer == null) return;

        newChannel.ServerId = selectedServer.ServerId;
        var createdChannel = await ChannelService.CreateChannelAsync(newChannel);

        if (createdChannel != null)
        {
            channels.Add(createdChannel);
            newChannel.ChannelName = string.Empty;
            showAddChannelInput = false;
        }
        else
        {
            await JSRuntime.InvokeVoidAsync("Swal.fire", "오류", "채널 생성에 실패했습니다.", "error");
        }
    }

    private async Task HandleChatInput(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrEmpty(messageInput))
        {
            // 연결 상태를 확인하여 안전하게 전송합니다.
            if (selectedTextChannel != null && hubConnection?.State == HubConnectionState.Connected)
            {
                // [중요] 서버의 SendMessage는 (channelId, message) 2개만 받습니다!
                // 사용자 이름은 서버가 토큰에서 직접 추출하므로 보낼 필요가 없습니다.
                await hubConnection.SendAsync("SendMessage", selectedTextChannel.ChannelId.ToString(), currentProfileUrl, messageInput);
                messageInput = string.Empty;
            }
        }
    }

    private async Task ScrollToBottomChatMessagesBox()
    {
        // 위에서 만든 JS 함수 호출
        await JSRuntime.InvokeVoidAsync("scrollToBottom", chatMessagesBox);
    }

    // 파일 선택 핸들러
    public async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file == null) return;

        // 파일 크기 체크 (예: 100MB 제한)
        long maxAllowedSize = 100 * 1024 * 1024;
        if (file.Size > maxAllowedSize)
        {
            await JSRuntime.InvokeVoidAsync("Swal.fire", "경고", "파일 크기가 너무 큽니다. (최대 100MB)", "warning");
            return;
        }

        try
        {
            // 파일 업로드 호출
            // 주의: fileService.UploadFileAsync 내부에서 stream을 열 때
            // file.OpenReadStream(maxAllowedSize) 처럼 크기를 인자로 전달해야 합니다.
            var uploadedFileDto = await fileService.UploadFileAsync(file);

            if (uploadedFileDto != null && selectedTextChannel != null && hubConnection?.State == HubConnectionState.Connected)
            {
                string messageType = file.ContentType.Contains("image") ? "image" :
                                     file.ContentType.Contains("video") ? "video" : "file";

                await hubConnection.SendAsync("SendMessageWithFile",
                    selectedTextChannel.ChannelId.ToString(),
                    uploadedFileDto.FileUrl,
                    messageType);
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("Swal.fire", "오류", "업로드에 실패했거나 연결이 끊어졌습니다.", "error");
            }
        }
        catch (Exception ex)
        {
            // 서버가 꺼지는 경우 여기도 도달하지 못할 수 있습니다.
            // 이는 서버의 Program.cs 설정이 우선적으로 해결되어야 함을 의미합니다.
            Console.WriteLine($"업로드 에러: {ex.Message}");
            await JSRuntime.InvokeVoidAsync("Swal.fire", "치명적 오류", $"파일 처리 중 오류 발생: {ex.Message}", "error");
        }
    }

    private string FormatMessage(string? userName, string? userProfileUrl, string type, string? fileUrl, DateTime timestamp, string? message)
    {
        // 프로필 이미지가 없으면 기본 원형 안에 첫 글자 표시
        var avatar = !string.IsNullOrEmpty(userProfileUrl)
            ? $"<img src='{userProfileUrl}' class='rounded-circle' style='width: 40px; height: 40px; object-fit: cover;' />"
            : $"<div class='bg-secondary rounded-circle d-flex align-items-center justify-content-center text-white' style='width: 40px; height: 40px;'>{userName[0]}</div>";

        var header = $"<div class='d-flex align-items-center mb-1'><div class='fw-bold' style='color: #00d1b2;'>{userName}</div></div>";
        var time = $"<div style='color:gray; font-size:0.75rem;'>{timestamp.ToLocalTime():HH:mm}</div>";

        if (type == "image")
            return $"<div class='flex-shrink-0'>{avatar}</div><div class='flex-grow-1 ms-3'>{header}<div><img src='{fileUrl}' style='max-width:350px; border-radius:12px; margin: 5px 0; border: 1px solid #444;' /></div>{time}</div>";

        if (type == "video")
            return $"<div class='flex-shrink-0'>{avatar}</div><div class='flex-grow-1 ms-3'>{header}<div><video src='{fileUrl}' controls style='max-width:350px; border-radius:12px; margin: 5px 0;' /></div>{time}</div>";

        // 일반 파일인 경우 다운로드 링크 제공
        if (type == "file")
            return $"<div class='flex-shrink-0'>{avatar}</div><div class='flex-grow-1 ms-3'>{header}<div><a href='{fileUrl}' target='_blank' class='btn btn-sm btn-outline-info'>📎 파일 다운로드</a></div>{time}</div>";

        return $"<div class='flex-shrink-0'>{avatar}</div><div class='flex-grow-1 ms-3'>{header}<div class='mt-1'>{message}</div>{time}</div>";
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            //이미 생성되어 있다면 재사용하거나 기존 것을 해제합니다.
            _objRef?.Dispose();
            _objRef = DotNetObjectReference.Create(this);

            await JSRuntime.InvokeVoidAsync("setupFileUpload", _objRef, "msgInput");
        }
    }

    // javascript에서 호출할 메서드 예시
    [JSInvokable]
    public async Task HandleFileFromJS(string fileName, string contentType, IJSStreamReference streamRef)
    {
        try
        {
            // JS로부터 스트림 열기 ( 최대 100MB)
            using var stream = await streamRef.OpenReadStreamAsync(maxAllowedSize: 100 * 1024 * 1024);
            // 파일 업로드 서비스 호출 (새로 만든 오버로드 사용)
            var uploadedFileDto = await fileService.UploadFileAsync(stream, fileName, contentType);

            if (uploadedFileDto != null && selectedTextChannel != null && hubConnection?.State == HubConnectionState.Connected)
            {
                string messageType = contentType.Contains("image") ? "image" :
                                     contentType.Contains("video") ? "video" : "file";
                await hubConnection.SendAsync("SendMessageWithFile",
                    selectedTextChannel.ChannelId.ToString(),
                    currentProfileUrl,
                    uploadedFileDto.FileUrl,
                    messageType);
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("Swal.fire", "오류", "드래그 앤 드랍 업로드에 실패했거나 연결이 끊어졌습니다.", "error");
            }

        }
        catch (Exception ex)
        {
            Console.WriteLine($"드래그 앤 드랍 업로드 에러: {ex.Message}");
            await JSRuntime.InvokeVoidAsync("Swal.fire", "오류", "드래그 앤 드랍 업로드 중 오류가 발생했습니다.", "error");
        }
    }

    // 프로필 영역 클릭 시 파일 선택창 띄우기
    private async Task TriggerProfileUpload()
    {
        await JSRuntime.InvokeVoidAsync("clickElement", "profileInput");
    }

    // 프로필 이미지 업로드 처리
    private async Task HandleProfileImageUpload(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file == null) return;

        try
        {
            // 1. 기존 FileService를 이용해 서버에 파일 저장
            var uploadedFile = await fileService.UploadFileAsync(file);

            // 2. 서버의 유저 정보 업데이트 API 호출
            await userService.UpdateProfileImageAsync(uploadedFile.FileUrl);
            currentProfileUrl = uploadedFile.FileUrl;

            await JSRuntime.InvokeVoidAsync("Swal.fire", "성공", "프로필 이미지가 변경되었습니다.", "success");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"프로필 업로드 에러: {ex.Message}");
        }
    }


    private async void LeaveVoiceChannel()
    {
        if (selectedVoiceChannel != null && hubConnection != null)
        {
            await hubConnection.SendAsync("LeaveVoiceGroup", selectedVoiceChannel.ChannelId.ToString());
            await JSRuntime.InvokeVoidAsync("webrtcFunctions.stopStream");
            selectedVoiceChannel = null;
        }
        StateHasChanged();
    }

    // IAsyncDisposable 구현 부분 수정
    public async ValueTask DisposeAsync()
    {
        // 앱 종료 시 음성 채널 퇴장 요청
        if (selectedVoiceChannel != null && hubConnection != null)
        {
            await hubConnection.SendAsync("LeaveVoiceGroup", selectedVoiceChannel.ChannelId.ToString());
            await JSRuntime.InvokeVoidAsync("webrtcFunctions.stopStream");
        }

        _objRef?.Dispose();
        if (hubConnection is not null) await hubConnection.DisposeAsync();
    }
}