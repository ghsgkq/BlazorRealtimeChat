@page "/"
@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))

@using System.Security.Claims
@using System.Text.Json
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.AspNetCore.Components.Authorization
@using BlazorRealtimeChat.Client.Layout
@using BlazorRealtimeChat.Client.Services
@using BlazorRealtimeChat.Shared.DTOs
@using Blazored.LocalStorage
@using Microsoft.JSInterop

@layout EmptyLayout
@implements IAsyncDisposable

@inject IAuthService AuthService
@inject IServiceProvider ServiceProvider
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime
@inject IServerService ServerService
@inject IChannelService ChannelService
@inject ILocalStorageService LocalStorage
@inject IMessageService messageService
@inject IFileService fileService

<div class="d-flex home-container">
    <!-- 1. 서버 목록 사이드바 -->
    <div class="server-list-sidebar d-flex flex-column align-items-center p-2">
        @if (servers != null)
        {
            @foreach (var server in servers)
            {
                <div class="server-icon @(selectedServer == server ? "selected" : "")" @onclick="() => SelectServer(server)">
                    @server.ServerName.Substring(0, 1)
                </div>
            }
        }
        <div class="server-separator"></div>
        <div class="server-icon" @onclick="HandleCreateServer">+</div>
    </div>

    <!-- 2. 채널 목록 사이드바 -->
    <div class="channel-sidebar bg-dark text-light flex-shrink-0" style="display: flex; flex-direction: column;">
        @if (selectedServer != null)
        {
            <div class="p-3 border-bottom border-secondary">
                <h5 class="fw-bold mb-0">@selectedServer.ServerName</h5>
            </div>
            <div class="d-flex justify-content-between align-items-center p-3">
                <span class="small text-uppercase">채널</span>
                <button class="btn btn-sm text-light" @onclick="ToggleAddChannelInput">+</button>
            </div>

            <ul class="list-unstyled p-2">
                @if (showAddChannelInput)
                {
                    <li class="p-2">
                        <EditForm Model="newChannel" OnValidSubmit="HandleCreateChannel">
                            <DataAnnotationsValidator />
                            <div class="input-group">
                                <InputText @bind-Value="newChannel.ChannelName" class="form-control form-control-sm bg-dark text-light border-secondary" placeholder="새 채널 이름" />
                                <button type="submit" class="btn btn-sm btn-success">✓</button>
                            </div>
                            <ValidationMessage For="@(() => newChannel.ChannelName)" />
                        </EditForm>
                    </li>
                }

                @if (isLoadingChannels)
                {
                    <li class="p-2 text-muted">채널 목록을 불러오는 중...</li>
                }
                else if (channels != null && channels.Any())
                {
                    @foreach (var channel in channels)
                    {
                        <li class="channel-item p-2 rounded @(selectedChannel == channel ? "selected" : "")" @onclick="() => SelectChannel(channel)">
                            <span># @channel.ChannelName</span>
                        </li>
                    }
                }
                else
                {
                    <li class="p-2 text-muted">채널이 없습니다.</li>
                }
            </ul>
        }
        <div class="user-profile mt-auto p-3 d-flex align-items-center">
            <span class="bg-secondary rounded-circle me-2" style="width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;">@currentUsername?.Substring(0,1).ToUpper()</span>
            <span class="fw-bold">@currentUsername</span>
        </div>
    </div>

    <!-- 3. 메인 콘텐츠 (채팅창) -->
    <div class="main-content d-flex flex-column flex-grow-1">
        <div class="chat-messages flex-grow-1 p-3" @ref="chatMessagesBox" style="overflow-y: auto;">
            @foreach (var message in chatMessages)
            {
                <div class="d-flex mb-3">
                    <div class="flex-shrink-0">
                        <span class="bg-secondary rounded-circle" style="width: 40px; height: 40px; display: block;"></span>
                    </div>
                    <div class="flex-grow-1 ms-3">
                        @((MarkupString)message)
                    </div>
                </div>
            }
        </div>

        <div class="chat-input p-3 bg-dark-subtle">
            <div class="input-group">
                @* 1. InputFile은 그대로 두되, ID를 확실히 지정합니다 *@
                <InputFile OnChange="HandleFileSelected" id="fileInput" style="display:none;" />

                @* 2. button 대신 label을 사용합니다. for="fileInput"이 핵심입니다! *@
                @* 이 label을 클릭하면 브라우저가 알아서 ID가 fileInput인 요소를 클릭해줍니다. *@
                <label for="fileInput" class="btn btn-outline-secondary text-light d-flex align-items-center justify-content-center" style="cursor: pointer; width: 45px;">
                    +
                </label>

                <input type="text" id="msgInput" class="form-control bg-dark text-light border-secondary"
                       placeholder="@($"# {selectedChannel?.ChannelName ?? ""}에 메시지 보내기")"
                       @bind="messageInput" @onkeyup="HandleChatInput" disabled="@(!isChatConnected)" />
            </div>
        </div>
    </div>
</div>

@code {
    private List<ServerDto> servers = new List<ServerDto>();
    private List<ChannelDto> channels = new List<ChannelDto>();
    private ServerDto? selectedServer;
    private ChannelDto? selectedChannel;
    private CreateChannelDto newChannel = new CreateChannelDto();
    private bool showAddChannelInput = false;
    private bool isLoadingChannels = false;

    // --- 채팅 관련 필드 ---
    [CascadingParameter]
    private Task<AuthenticationState>? AuthenticationStateTask { get; set; }
    private HubConnection? hubConnection;
    private List<string> chatMessages = new List<string>();
    private string? messageInput;
    private string? currentUsername;
    private bool isChatConnected => hubConnection?.State == HubConnectionState.Connected;

    private Task? _signalRInitTask; // SignalR 초기화 상태를 추적하는 태스크

    private ElementReference chatMessagesBox; // 채팅 Dom 참조

    private DotNetObjectReference<Home>? _objRef; // 필드로 선언

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateTask;
        currentUsername = authState.User.FindFirst("name")?.Value ?? "Anonymous";

        // 1. 초기화 태스크를 변수에 저장합니다. (await 하지 않고 바로 다음으로 넘어감)
        _signalRInitTask = InitializeSignalR();

        // 2. 서버 목록은 바로 불러옵니다.
        await LoadInitialServers();
    }

    private async Task InitializeSignalR()
    {
        // 1. HubConnection 빌드 (기존과 동일)
        hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri("/chathub"), options =>
            {
                options.AccessTokenProvider = async () =>
                    await LocalStorage.GetItemAsync<string>("accessToken");
            })
            .WithAutomaticReconnect()
            .Build();

        // 메시지 수신 핸들러 등록
        hubConnection.On<string, string>("ReceiveMessage", async (user, message) =>
        {
            var formattedMessage = FormatMessage(user, "text", "", DateTime.Now, message);
            chatMessages.Add(formattedMessage);
            await InvokeAsync(StateHasChanged);
            // 메시지 최신화 후, 메시지 스크롤을 가장 아래로 내린다.
            await ScrollToBottomChatMessagesBox();
        });

        // 파일 메시지 수신 핸들러 등록
        hubConnection.On<string, string, string>("ReceiveMessageWithFile", async (userName, fileUrl, messageType) =>
        {
            var fileMessageHtml = FormatMessage(userName, messageType, fileUrl, DateTime.Now, "");
            chatMessages.Add(fileMessageHtml);
            await InvokeAsync(StateHasChanged);
            // 메시지 최신화 후, 메시지 스크롤을 가장 아래로 내린다.
            await Task.Delay(100);
            await ScrollToBottomChatMessagesBox();

        });

        try
        {
            // 2. 서버와 연결 시작
            await hubConnection.StartAsync();
            Console.WriteLine("SignalR 연결 성공!");

            // [핵심] 연결이 완료되었음을 UI에 알려 input의 disabled를 해제합니다.
            await InvokeAsync(StateHasChanged);

            // [추가] 연결 전에 이미 채널이 선택되어 있었다면, 지금 서버에 Join을 요청합니다.
            if (selectedChannel != null)
            {
                await hubConnection.SendAsync("JoinChannel", selectedChannel.ChannelId.ToString());
                Console.WriteLine($"연결 후 채널 입장 완료: {selectedChannel.ChannelName}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"SignalR 연결 실패: {ex.Message}");
        }
    }

    private async Task LoadInitialServers()
    {
        try
        {
            servers = await ServerService.GetServersAsync();
            if (servers != null && servers.Any())
            {
                await SelectServer(servers.First());
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"서버 목록을 불러오는 데 실패했습니다: {ex.Message}");
        }
    }

    private async Task SelectServer(ServerDto server)
    {
        selectedServer = server;
        selectedChannel = null; // 다른 서버 선택 시, 현재 선택된 채널을 초기화합니다.
        isLoadingChannels = true;
        channels = new List<ChannelDto>(); 
        chatMessages.Clear();
        StateHasChanged();

        try
        {
            // Api 호출 직전 로그
            Console.WriteLine($"호출 중: api/servers/{server.ServerId}/channels");

            channels = await ChannelService.GetChannelsAsync(server.ServerId);

            // 2. 데이터 확인 로그
            Console.WriteLine($"가져온 채널 개수: {channels?.Count ?? 0}");
        }
        catch (Exception ex)
        { 
            Console.WriteLine($"{server.ServerName} 서버의 채널 목록을 불러오는 데 실패했습니다: {ex.Message}");
            channels = new List<ChannelDto>();
        }
        finally
        {
            isLoadingChannels = false;
        }

        // 서버를 선택하면 첫 번째 채널을 자동으로 선택
        if (channels != null && channels.Any())
        {
            await SelectChannel(channels.First());
        }
        else
        {
            // 채널이 없는 경우, UI를 한번 더 갱신하여 "채널을 선택하세요"가 표시되도록 합니다.
            StateHasChanged();
        }
    }
    private async Task SelectChannel(ChannelDto channel)
    {
        if (channel == null) return;

        // 1. hubConnection이 생성되었고 연결된 상태인지 먼저 확인합니다.
        if (hubConnection != null && hubConnection.State == HubConnectionState.Connected)
        {
            try
            {
                // 2. 기존에 선택된 채널이 있었다면 먼저 나갑니다.
                if (selectedChannel != null)
                {
                    await hubConnection.SendAsync("LeaveChannel", selectedChannel.ChannelId.ToString());
                }

                selectedChannel = channel;
                chatMessages.Clear();

                // 메시지 로드
                var history = await messageService.GetMessagesByChannelIdAsync(channel.ChannelId);
                foreach (var msg in history)
                {
                    var formattedMessage = FormatMessage(
                        msg.UserName,
                        msg.MessageType,
                        msg.FileUrl,
                        msg.Timestamp,
                        msg.Content);
                    chatMessages.Add(formattedMessage);                  
                }

                // 3. 서버의 JoinChannel 메서드를 호출합니다.
                await hubConnection.SendAsync("JoinChannel", selectedChannel.ChannelId.ToString());
            }
            catch (Exception ex)
            {
                // 여기서 에러가 나더라도 UI 상태는 업데이트하여 선택은 되게 합니다.
                Console.WriteLine($"채널 입장 중 SignalR 오류: {ex.Message}");
            }
        }
        else
        {
            // 연결 전이라면 화면에 표시할 데이터만 업데이트합니다.
            selectedChannel = channel;
            chatMessages.Clear();


        }

        StateHasChanged();
        // 메시지 최신화 후, 메시지 스크롤을 가장 아래로 내린다.
        await ScrollToBottomChatMessagesBox();

    }

    private async Task HandleCreateServer()
    {
        // SweetAlert2는 string이 아닌 JSON 객체를 반환하므로, JsonElement로 받습니다.
        var swalResult = await JSRuntime.InvokeAsync<JsonElement>("Swal.fire", new
        {
            title = "새 서버 만들기",
            text = "서버 이름을 입력하세요:",
            input = "text",
            showCancelButton = true,
            confirmButtonText = "만들기",
            cancelButtonText = "취소"
        });

        // 사용자가 '취소'를 누르지 않았고, 'value' 속성이 존재하는지 확인합니다.
        if (swalResult.TryGetProperty("value", out var valueElement) && valueElement.ValueKind == JsonValueKind.String)
        {
            string serverName = valueElement.GetString();

            if (string.IsNullOrWhiteSpace(serverName)) return;

            try
            {
                var newServerDto = new CreateServerDto { ServerName = serverName };
                var createdServer = await ServerService.CreateServerAsync(newServerDto);

                if (createdServer != null)
                {
                    servers.Add(createdServer);
                    await SelectServer(createdServer);
                    StateHasChanged();
                }
                else
                {
                    await JSRuntime.InvokeVoidAsync("Swal.fire", "오류", "서버를 만들지 못했습니다. API가 null을 반환했습니다.", "error");
                }
            }
            catch (Exception ex)
            {
                await JSRuntime.InvokeVoidAsync("Swal.fire", "치명적 오류", $"서버 생성 중 예외가 발생했습니다: {ex.Message}", "error");
            }
        }
    }

    private void ToggleAddChannelInput()
    {
        showAddChannelInput = !showAddChannelInput;
    }

    private async Task HandleCreateChannel()
    {
        if (selectedServer == null) return;

        newChannel.ServerId = selectedServer.ServerId;
        var createdChannel = await ChannelService.CreateChannelAsync(newChannel);

        if (createdChannel != null)
        {
            channels.Add(createdChannel);
            newChannel.ChannelName = string.Empty;
            showAddChannelInput = false;
        }
        else
        {
            await JSRuntime.InvokeVoidAsync("Swal.fire", "오류", "채널 생성에 실패했습니다.", "error");
        }
    }

    private async Task HandleChatInput(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrEmpty(messageInput))
        {
            // 연결 상태를 확인하여 안전하게 전송합니다.
            if (selectedChannel != null && hubConnection?.State == HubConnectionState.Connected)
            {
                // [중요] 서버의 SendMessage는 (channelId, message) 2개만 받습니다!
                // 사용자 이름은 서버가 토큰에서 직접 추출하므로 보낼 필요가 없습니다.
                await hubConnection.SendAsync("SendMessage", selectedChannel.ChannelId.ToString(), messageInput);
                messageInput = string.Empty;
            }
        }
    }

    private async Task ScrollToBottomChatMessagesBox()
    {
        // 위에서 만든 JS 함수 호출
        await JSRuntime.InvokeVoidAsync("scrollToBottom", chatMessagesBox);
    }

    // 파일 선택 핸들러
    public async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file == null) return;

        // 파일 크기 체크 (예: 100MB 제한)
        long maxAllowedSize = 100 * 1024 * 1024;
        if (file.Size > maxAllowedSize)
        {
            await JSRuntime.InvokeVoidAsync("Swal.fire", "경고", "파일 크기가 너무 큽니다. (최대 100MB)", "warning");
            return;
        }

        try
        {
            // 파일 업로드 호출
            // 주의: fileService.UploadFileAsync 내부에서 stream을 열 때
            // file.OpenReadStream(maxAllowedSize) 처럼 크기를 인자로 전달해야 합니다.
            var uploadedFileDto = await fileService.UploadFileAsync(file);

            if (uploadedFileDto != null && selectedChannel != null && hubConnection?.State == HubConnectionState.Connected)
            {
                string messageType = file.ContentType.Contains("image") ? "image" :
                                     file.ContentType.Contains("video") ? "video" : "file";

                await hubConnection.SendAsync("SendMessageWithFile",
                    selectedChannel.ChannelId.ToString(),
                    uploadedFileDto.FileUrl,
                    messageType);
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("Swal.fire", "오류", "업로드에 실패했거나 연결이 끊어졌습니다.", "error");
            }
        }
        catch (Exception ex)
        {
            // 서버가 꺼지는 경우 여기도 도달하지 못할 수 있습니다.
            // 이는 서버의 Program.cs 설정이 우선적으로 해결되어야 함을 의미합니다.
            Console.WriteLine($"업로드 에러: {ex.Message}");
            await JSRuntime.InvokeVoidAsync("Swal.fire", "치명적 오류", $"파일 처리 중 오류 발생: {ex.Message}", "error");
        }
    }

    private string FormatMessage(string userName, string type, string fileUrl, DateTime timestamp, string message)
    {
        var header = $"<div class='fw-bold' style='color: #00d1b2;'>{userName}</div>";
        var time = $"<div style='color:gray; font-size:0.75rem;'>{timestamp.ToLocalTime():HH:mm}</div>";

        if (type == "image")
            return $"{header}<div><img src='{fileUrl}' style='max-width:350px; border-radius:12px; margin: 5px 0; border: 1px solid #444;' /></div>{time}";

        if (type == "video")
            return $"{header}<div><video src='{fileUrl}' controls style='max-width:350px; border-radius:12px; margin: 5px 0;' /></div>{time}";

        // 일반 파일인 경우 다운로드 링크 제공
        if (type == "file")
            return $"{header}<div><a href='{fileUrl}' target='_blank' class='btn btn-sm btn-outline-info'>📎 파일 다운로드</a></div>{time}";

        return $"{header}<div class='mt-1'>{message}</div>{time}";
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            //이미 생성되어 있다면 재사용하거나 기존 것을 해제합니다.
            _objRef?.Dispose();
            _objRef = DotNetObjectReference.Create(this);

            await JSRuntime.InvokeVoidAsync("setupFileUpload", _objRef, "msgInput");
        }
    }

    // javascript에서 호출할 메서드 예시
    [JSInvokable]
    public async Task HandleFileFromJS(string fileName, string contentType, IJSStreamReference streamRef)
    {
        try
        {
            // JS로부터 스트림 열기 ( 최대 100MB)
            using var stream = await streamRef.OpenReadStreamAsync(maxAllowedSize: 100 * 1024 * 1024);
            // 파일 업로드 서비스 호출 (새로 만든 오버로드 사용)
            var uploadedFileDto = await fileService.UploadFileAsync(stream, fileName, contentType);

            if(uploadedFileDto != null && selectedChannel != null && hubConnection?.State == HubConnectionState.Connected)
            {
                string messageType = contentType.Contains("image") ? "image" :
                                     contentType.Contains("video") ? "video" : "file";
                await hubConnection.SendAsync("SendMessageWithFile",
                    selectedChannel.ChannelId.ToString(),
                    uploadedFileDto.FileUrl,
                    messageType);
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("Swal.fire", "오류", "드래그 앤 드랍 업로드에 실패했거나 연결이 끊어졌습니다.", "error");
            }

        }
        catch (Exception ex)
        {
            Console.WriteLine($"드래그 앤 드랍 업로드 에러: {ex.Message}");
            await JSRuntime.InvokeVoidAsync("Swal.fire", "오류", "드래그 앤 드랍 업로드 중 오류가 발생했습니다.", "error");
        }
    }


    // IAsyncDisposable 구현 부분 수정
    public async ValueTask DisposeAsync()
    {
        _objRef?.Dispose(); // [중요] 생성한 참조를 반드시 해제합니다.
        if (hubConnection is not null) await hubConnection.DisposeAsync();
    }
}

<style>
    .channel-item.selected {
        background-color: var(--bs-secondary); /* Bootstrap의 secondary 색상을 사용 */
    }
    .channel-item:hover {
        background-color: var(--bs-gray-700);
    }
</style>
