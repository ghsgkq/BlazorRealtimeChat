<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />
    @* 제가 멋대로 삭제했던, .NET 8의 올바른 정적 에셋 참조 방식입니다. *@
    <link rel="stylesheet" href="@Assets["lib/bootstrap/dist/css/bootstrap.min.css"]" />
    <link rel="stylesheet" href="@Assets["app.css"]" />
    <link rel="stylesheet" href="@Assets["BlazorRealtimeChat.styles.css"]" />
    <link rel="stylesheet" href="@Assets["BlazorRealtimeChat.Client.styles.css"]" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">
    <ImportMap />
    <link rel="icon" type="image/png" href="favicon.png" />
    <HeadOutlet />
</head>

<body>
    @* 사전 렌더링을 비활성화하는 올바른 설정은 그대로 유지합니다. *@
    <Routes @rendermode="new InteractiveWebAssemblyRenderMode(prerender: false)" />
    <script src="_framework/blazor.web.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

    <script>
         // 스크롤을 최하단으로 이동시키는 함수
         window.scrollToBottom = (element) => {
            if (!element) return;

            // 스크롤을 끝으로 내리는 내부 함수
            const doScroll = () => {
                element.scrollTop = element.scrollHeight;
            };

            // 즉시 스코를 수행
            doScroll();

                // 현재 요소 내의 모든 이미지와 비디오가 로드될 때마다 스크롤 다시 수행 (핵심!)
            const mediaElements = element.querySelectorAll('img, video');
            mediaElements.forEach(media => {
            // 이미 로드된 경우를 대비해 이벤트 리스너 등록
                media.addEventListener('load', doScroll, { once: true });
                media.addEventListener('loadeddata', doScroll, { once: true });
            });

            // 브라우저 렌더링 타이밍을 고려해 아주 짧은 지연 후 다시 한 번 수행
            setTimeout(doScroll, 100);

        };

        window.setupFileUpload = (dotNetHelper, elementId) => {
            const element = document.getElementById(elementId);
            if (!element) return;

            // 붙여넣기(Paste) 처리
            element.addEventListener('paste', async (e) => {
                const items = e.clipboardData.items;
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf('image') !== -1 || items[i].type.indexOf('video') !== -1) {
                        const file = items[i].getAsFile();
                        await uploadFileFromJS(dotNetHelper, file);
                    }
                }
            });

            // 드롭(Drop) 처리
            element.addEventListener('drop', async (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file) {
                // 파일을 스트림 참조로 변환
                const streamRef = DotNet.createJSStreamReference(file);
                // [중요] C#의 매개변수 순서(fileName, contentType, streamRef)와 일치하게 보냅니다.
                await dotNetHelper.invokeMethodAsync('HandleFileFromJS', file.name, file.type, streamRef);
            }
        });

            element.addEventListener('dragover', (e) => {
                e.preventDefault();
                element.classList.add('drag-over');
            });

            element.addEventListener('dragleave', () => {
                element.classList.remove('drag-over');
            });
        };

        window.clickElementById = (id) => {
            const element = document.getElementById(id);
            if (element) {
                element.click();
            }
        };

        window.clickElement = (id) => {
            const el = document.getElementById(id);
            if (el) {
                el.click();
            }
        };

        async function uploadFileFromJS(dotNetHelper, file) {
            // 파일을 바이트 배열로 변환하여 C#으로 전달
            const arrayBuffer = await file.arrayBuffer();
            const byteArray = new Uint8Array(arrayBuffer);
            await dotNetHelper.invokeMethodAsync('HandleFileFromJS', byteArray, file.name, file.type);
        }
    </script>
</body>

</html>
